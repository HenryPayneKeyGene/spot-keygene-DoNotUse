#  Copyright (c) Romir Kulshrestha 2023.
#  You may use, distribute and modify this code under the terms of the MIT License.
#  You should have received a copy of the MIT License with this file. If not, please visit:
#  https://opensource.org/licenses/MIT

"""
This module contains the main entry point for the Spot Keygene application.
"""
import curses
import logging
import os
import traceback
from xmlrpc.client import ResponseError

from bosdyn.client import RpcError
from bosdyn.client.lease import LeaseKeepAlive
from bosdyn.client.util import setup_logging

from .blk import BLK
from .recording import RecorderInterface
from .spot import Spot
from .util import countdown


class Run:
    def __init__(self, config):
        self.config = config
        self.logger = logging.getLogger(__name__)

        self.logger.info("Starting up")
        self.robot = Spot(config['spot'])
        self.lidar = BLK()
        # self.nav = self.robot.graph_nav_interface

        self.starting_fiducial = config['starting_fiducial']

    def __del__(self):
        if hasattr(self, "robot"):
            self.robot.shutdown()
        if hasattr(self, "lidar"):
            self.lidar.shutdown()

    def record_mission(self):
        recorder = RecorderInterface(self.robot)
        stream_handler = setup_logging()
        with LeaseKeepAlive(self.robot.lease_client, must_acquire=True, return_at_exit=True) as lease_keep_alive:
            try:
                recorder.start(lease_keep_alive)
            except (ResponseError, RpcError) as err:
                self.logger.error('Failed to initialize robot communication: %s', err)
                return False

            try:
                # Prevent curses from introducing a 1-second delay for ESC key
                os.environ.setdefault('ESCDELAY', '0')
                # Run recorder interface in curses mode, then restore terminal config.
                curses.wrapper(recorder.drive)
            except Exception as e:
                self.logger.error('Mission recorder has thrown an error: %r', e)
                self.logger.error(traceback.format_exc())
            finally:
                # Restore stream handler after curses mode.
                self.logger.addHandler(stream_handler)
        self.logger.info('Mission recorder has exited.')

    def autowalk(self, mission_file):
        """Walk around the environment and collect data."""

        # load mission from file
        # Check if mission_file exists.
        if not os.path.isfile(mission_file):
            # If this is a non-custom autowalk mission, there were checks for both "autogenerated" and
            # "autogenerated.node" files.
            self.logger.fatal(f'Unable to find mission file: {mission_file} or {mission_file + ".node"}.')
            return

        # upload graph and mission
        self.logger.info("Uploading mission data...")
        self.nav.upload_graph_and_snapshots()
        self.nav.upload_mission(mission_file)

        # wait for fiducial
        self.logger.info(f"Looking for fiducial {self.starting_fiducial}...")
        self.robot.release()
        self.robot.release_estop()
        self.robot.recording_interface.wait_for_fiducial(self.starting_fiducial)

        # reset robot
        self.logger.info("Resetting robot...")
        self.robot.power_off()

        # run mission
        self.logger.info("Starting mission...")
        countdown(5)
        self.nav.run_mission()
